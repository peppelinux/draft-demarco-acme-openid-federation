{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-10-03T00:33:41.949768+00:00",
  "repo": "peppelinux/draft-demarco-acme-openid-federation",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJ6_NW859ms0D",
      "title": "specialized keys by scopes",
      "url": "https://github.com/peppelinux/draft-demarco-acme-openid-federation/issues/1",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "we need a way (optional) to define the scope of the key where the issued certificate is related to",
      "createdAt": "2024-01-30T09:07:23Z",
      "updatedAt": "2024-01-30T09:07:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOJ6_NW86UD4xZ",
      "title": "Questions regarding the specification",
      "url": "https://github.com/peppelinux/draft-demarco-acme-openid-federation/issues/2",
      "state": "OPEN",
      "author": "branlwyd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I gave the specification (as well as the ACME & OpenID Federation specs) a readthrough. I have a few initial questions:\r\n\r\n1) What kind of X.509 certificates are intended to be generated? For example, the original ACME specification generates domain-validated Web PKI certificates (RFC 8555). It has been extended to create S/MIME certificates (RFC 8823), VoIP certificates (RFC 9448), and probably others. The text in Section 6.8 suggests this may be a Web PKI certificate, but this is not totally clear.\r\n\r\n2) It looks like the ACME authorizations/challenges functionality is not used in this proposal (Section 6.7 says it `MUST` be omitted from the `newOrder` response). Instead, my understanding is that issuance is authorized by having the `newOrder` request signed by a private key controlled by the Requestor & published in its Entity Configuration (Section 5), which may be discovered by the Issuer or included in a new `trust_chain` request field. Is this accurate?\r\n\r\n[nit: Section 5 says the `newOrder` request is signed by the Requestor's private key, while Section 6.2 suggests that the `newNonce` request requires validation. Perhaps both should be?]\r\n\r\n3) Given that requests are expected to be signed with the Requestor's private key, how does this play with standard ACME account management? Standard ACME account management maintains that each client will maintain its own keypair, and each request is authorized by a signature over the request with the account's private key.\r\n\r\n\r\nAnd a final meta-question, wrapping up the previous three questions: why can't this method of authorizing issuance be phrased as a new challenge type, using ACME's existing authorization/challenge/response APIs? For example, the challenge would include a nonce, and the response would involve providing a signature over the nonce with the Entity Key. This would fit more closely to ACME as defined in RFC 8555 as well as existing extensions.",
      "createdAt": "2024-08-23T23:43:26Z",
      "updatedAt": "2024-09-03T19:23:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "body": "Hi @branlwyd, thank you for your analysis and apologies for the late in reply\r\n\r\n1. in RFC7517, then in the JWK sets, we don't have any particular extension like the ones that might be possibile using X.509. OpenID Federation and its Entity Configurations carrying JWKs doesn't give this kind of detail. I assume for now that any X.509 extension would be exclusively in the scope of the ACME request therefore configured in the CSR. We can evaluate any further feature or requirement, therefore if of interest we can do any proposals for this point.\r\n\r\n2. yes it is accurate. Another issue is that in the current text we only mention/use Federation JWK and not metadata JWK. I believe that we need to include also metadata JWK, therefore the ACME request, including the jwk id (`kid`), must contain the pointer to the jwk inteded to be used for the evaluation. the trust chain is build, the federation jwks and any metadata specific jwks resolved, and then the public key material contained in the CSR must be matched with the specific jwk included in the acme request. If we need to clarify this point we can accurately define an issue with the instruction where and how to include this detail and therefore having another draft.\r\n\r\n2.1  good catch. I see that the check described in the following sentence cannot be evaluated by the issuer `The Requestor checks if its superior Federation Entity supports the ACME protocol for OpenID Connect Federation 1.0. If not, the Requestor starts the discovery process to find which are the Issuers within the federation.` . We can say that at that stage, i nthe nonce endpoint, the issuer doesn't have any way to know if the requestor is a federation participant, since from the http perspective the issuer has only the requestor's IP and not the requestor federation entity id. **This is an issue to be resolved in the current draft**.\r\n\r\n3. in multilateral federation the account is something that might be preestablished. an accout might rely on some bilateral contracts or relationship stipulated before the ACME request. It is in the scope of this draft enable the trust evaluation in the context of the multilateral federation allowing a more flexible x.509 certificate issuance according to the evidences evaluated though openid federation. In this draft the requestor's keys are not configured in a preconfigured account but in its trust chain dynamically evaluated during the ACME request. This must not alienate us, we might enable the account creation as well using openid federation; the current proposal aims to simplify by removing steps not necessarly of interest in the multilateral federations (or, at least for now, in my modest perception)\r\n\r\nfinal question/answer: the more we can reuse preexisting ACME approaches the more we can reduce implementation efforts. I support any change to the draft that aims to go in this direction of preserving legacy ACME implementation and using the less effort to include openid federation like a sort of wrapper, that might work around the ACME challenges and any other legacy artifact involved in the traditional flow.\r\n\r\ntherefore, if you want to propose a breaking change with your proposal please open a draft PR and consider all my support during the revision for releasing together the next draft\r\n\r\n\r\n ",
          "createdAt": "2024-08-27T21:40:54Z",
          "updatedAt": "2024-08-27T21:43:40Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "body": "1. Sounds good; I think we eventually need to think through what kind of CSRs are acceptable, but this doesn't need to be spelled out in the spec (RFC 8555 & RFC 8823 spell out CSR requirements in general terms; RFC 9448 provides more detail but still looks non-comprehensive).\r\n\r\nFinal: Sounds good, I will open a PR in the next few days -- it will likely phrase the authorization logic as a new challenge type.",
          "createdAt": "2024-08-28T20:44:34Z",
          "updatedAt": "2024-08-28T20:44:34Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "body": "I sent https://github.com/peppelinux/draft-demarco-acme-openid-federation/pull/3 as a WIP example of my suggestion to phrase the validation as a new ACME challenge type. Feedback very welcome; I will clean it up and turn it into a proper PR if the approach is acceptable.",
          "createdAt": "2024-08-30T23:36:15Z",
          "updatedAt": "2024-08-30T23:36:15Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "body": "Ok, I have added my first review with some suggestions",
          "createdAt": "2024-09-03T19:23:09Z",
          "updatedAt": "2024-09-03T19:23:09Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDOJ6_NW856CIbm",
      "title": "WIP: rephrase OpenID federation validation as a new challenge type.",
      "url": "https://github.com/peppelinux/draft-demarco-acme-openid-federation/pull/3",
      "state": "OPEN",
      "author": "branlwyd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-30T23:32:27Z",
      "updatedAt": "2024-10-02T22:57:17Z",
      "baseRepository": "peppelinux/draft-demarco-acme-openid-federation",
      "baseRefName": "main",
      "baseRefOid": "5f1e34bcb3bdd432f146773537c3cca10c9b6c8a",
      "headRepository": "branlwyd/draft-demarco-acme-openid-federation",
      "headRefName": "bran/challenge",
      "headRefOid": "22589fe6fe6c76989877cf708ebf4532389a2950",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJ6_NW86Hy3vC",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:09:37Z",
          "updatedAt": "2024-09-03T19:09:37Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "```suggestion\r\ndomain and its underlying endpoints using the trust evaluation mechanism provided by OpenID Federation 1.0. The client demonstrates control\r\n```\r\nI would not say mutual because the client has discovered in a previous moment all the ACME certificate issuers within a large scale federation, and at the time of the acme request only the acme issuers needs to evaluate the trust with the client",
              "createdAt": "2024-09-03T19:09:37Z",
              "updatedAt": "2024-09-03T19:09:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy4Lp",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:10:27Z",
          "updatedAt": "2024-09-03T19:10:28Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nof a cryptographic public key published in its OpenID Federation Entity Configuration, which the ACME server uses\r\n```",
              "createdAt": "2024-09-03T19:10:27Z",
              "updatedAt": "2024-09-03T19:10:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy4vw",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:11:31Z",
          "updatedAt": "2024-09-03T19:11:31Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "requirement:\r\n\r\nthe domain must be part of the client_id and therefore of the http url used in the value of the parameter `sub` contained in the entity configuration ",
              "createdAt": "2024-09-03T19:11:31Z",
              "updatedAt": "2024-09-03T19:11:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy6dY",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:15:11Z",
          "updatedAt": "2024-09-03T19:15:11Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "```suggestion\r\n    field; otherwise, the ACME server MUST start a Federation Entity Discovery about the client\r\n```\r\n\r\nhow the acme issuer know which is the client's entity id? suggest to add it in the previous object to provide a way to the acme issuer to fetch the entity configuration, when the trust chain is not provided within the request",
              "createdAt": "2024-09-03T19:15:11Z",
              "updatedAt": "2024-09-03T19:15:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy66Q",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:16:07Z",
          "updatedAt": "2024-09-03T19:16:08Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "\r\n```suggestion\r\nOnce the ACME issuer sends the request the client responds with an object with the following format:\r\n```\r\n\r\nthe acme issuer http request needs to be further described using a non-normative example about the http request",
              "createdAt": "2024-09-03T19:16:08Z",
              "updatedAt": "2024-09-03T19:16:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy7CS",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:16:23Z",
          "updatedAt": "2024-09-03T19:16:24Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "```suggestion\r\n    encoded in UTF-8 with one of the keys published in the client's OpenID Federation Entity\r\n```",
              "createdAt": "2024-09-03T19:16:23Z",
              "updatedAt": "2024-09-03T19:16:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy7b7",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:17:10Z",
          "updatedAt": "2024-09-03T19:17:11Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "```suggestion\r\ntrust_chain (optional, array of string):  an array of base64url-encoded bytes containing a signed JWT and\r\n```",
              "createdAt": "2024-09-03T19:17:10Z",
              "updatedAt": "2024-09-03T19:17:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy8Qn",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:18:34Z",
          "updatedAt": "2024-09-03T19:18:34Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "another requirement is that the client, within its trust chain, SHOULD use the same trust anchor that it has in common with the acme issuer, in other words the trust anchor used to evaluate the trust with the acme issuer",
              "createdAt": "2024-09-03T19:18:34Z",
              "updatedAt": "2024-09-03T19:18:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy8ik",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:19:01Z",
          "updatedAt": "2024-09-03T19:19:01Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "```suggestion\r\n       \"kid\": \"1\",\r\n```",
              "createdAt": "2024-09-03T19:19:01Z",
              "updatedAt": "2024-09-03T19:19:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy8wR",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:19:26Z",
          "updatedAt": "2024-09-03T19:19:26Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "```suggestion\r\n   Host: client.example.com\r\n```",
              "createdAt": "2024-09-03T19:19:26Z",
              "updatedAt": "2024-09-03T19:19:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy9k7",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:20:59Z",
          "updatedAt": "2024-09-03T19:20:59Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "I would move this note out of the brackets and configuring it as a normative requirement\r\n\r\nthe client can only request certificate about the FQDN used in its federation entity id",
              "createdAt": "2024-09-03T19:20:59Z",
              "updatedAt": "2024-09-03T19:20:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Hy-Wh",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-03T19:22:28Z",
          "updatedAt": "2024-09-03T19:22:28Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "provide failure behaviour such as giving http response error code in the form of non-normative example and according to the ACME specs legacy",
              "createdAt": "2024-09-03T19:22:28Z",
              "updatedAt": "2024-09-03T19:22:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86IVMZR",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-06T22:59:38Z",
          "updatedAt": "2024-09-06T22:59:38Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "I pulled in the following requirement around validation, attempting to match the existing check on the identifier the client is requesting issuance for:\r\n\r\n> Verifies that the requested domain names match the FQDN contained within the `iss` parameter of the client's Entity Configuration.\r\n\r\nThe [OpenID Federation 1.0's Entity Statement](https://openid.net/specs/openid-federation-1_0.html#name-entity-statement) section says:\r\n\r\n> iss\r\n> REQUIRED. The Entity Identifier of the issuer of the Entity Statement. If the iss and the sub are identical, the issuer is making an Entity Statement about itself called an Entity Configuration.\r\n\r\nSince we are explicitly checking the client's Entity Configuration, technically speaking, I think `iss` & `sub` are identical here. (Please correct me if I am wrong here.) Conceptually, however, I think `sub` makes more sense than `iss` since we are interested in knowing the subject of the configuration; I have made the suggested change to the requirements.",
              "createdAt": "2024-09-06T22:59:38Z",
              "updatedAt": "2024-09-06T22:59:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86IVOoO",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-06T23:17:51Z",
          "updatedAt": "2024-09-06T23:17:51Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "I think this is right, currently -- this would be an ACME account key, rather than a key published in the client's Entity Configuration. (I think it's valuable to maintain the concept of ACME accounts separately from the OpenID Entity Configurations since (a) ACME implementations will generally expect accounts to exist and (b) the ACME implementation may wish to implement account controls/rate-limiting/etc at the level of ACME accounts rather than OpenID Entities, i.e. individual domains.)\r\n\r\nHowever, we could add a `kid` field to the payload of the challenge, indicating which key in the Entity Configuration to use to validate the signature. What do you think?",
              "createdAt": "2024-09-06T23:17:51Z",
              "updatedAt": "2024-09-06T23:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86IVOxb",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-06T23:19:07Z",
          "updatedAt": "2024-09-06T23:19:08Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "This request is to the issuer, i.e. the ACME server, rather than the client.",
              "createdAt": "2024-09-06T23:19:07Z",
              "updatedAt": "2024-09-06T23:19:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86IVQXZ",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-06T23:33:10Z",
          "updatedAt": "2024-09-06T23:33:10Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "IMO, we should follow the ACME spec as well as RFC 8737, RFC 8823 -- these all define challenge types in terms of success or failure, relying on [RFC 8555 section 7.3.1](https://datatracker.ietf.org/doc/html/rfc8555/#section-7.5.1) to generically define how success/failure of an authorization attempt is handled.\r\n\r\nI added some text referring to this section.",
              "createdAt": "2024-09-06T23:33:10Z",
              "updatedAt": "2024-09-06T23:33:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86IVRWL",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-06T23:43:15Z",
          "updatedAt": "2024-09-06T23:43:15Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "Which request? The client's response has a non-normative example below; the rest of the process is standard ACME as described in RFC 8555.",
              "createdAt": "2024-09-06T23:43:15Z",
              "updatedAt": "2024-09-06T23:43:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86IVSKL",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-06T23:52:48Z",
          "updatedAt": "2024-09-06T23:52:48Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "> how the acme issuer know which is the client's entity id? suggest to add it in the previous object to provide a way to the acme issuer to fetch the entity configuration, when the trust chain is not provided within the request\r\n\r\nI added text to this effect.\r\n\r\nFor my own education: is there a reason we couldn't start federation entity discovery based on the FQDN contained in the identifier? For example, could multiple Entities have Entity Configurations with the same FQDN in `iss`? Or maybe it is impractical to look up entities based on partial Entity IDs, even if the FQDN is unique?\r\n\r\n> another requirement is that the client, within its trust chain, SHOULD use the same trust anchor that it has in common with the acme issuer, in other words the trust anchor used to evaluate the trust with the acme issuer\r\n\r\nAdded text to this effect. Why is this a `SHOULD` rather than a `MUST` -- what behavior would we expect of the server if the client sends a trust chain to an anchor it does not trust? (Failure would be the most likely response, but I think we could also allow the server to perform Entity Discovery if it receives a trust chain that it can't verify.)",
              "createdAt": "2024-09-06T23:52:48Z",
              "updatedAt": "2024-09-06T23:52:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86KRthP",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-21T20:12:46Z",
          "updatedAt": "2024-09-21T20:12:46Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "yes, in a entity configuration iss and sub are identical (while in a subordinate statements not).\r\n\r\n",
              "createdAt": "2024-09-21T20:12:46Z",
              "updatedAt": "2024-09-21T20:12:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86KRtpe",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-21T20:18:36Z",
          "updatedAt": "2024-09-21T20:18:36Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "we use entity id using https url, therefore more than a single FQDN, since within the same hostname/domain we might have more entities with different, even if derived from the same FQDN, entities (eg: multitenancy)\r\n\r\nthere might be implementations/deployments that wants to use federation in a more \"decentralized\" way (such as openid gain-poc wg) where RP of federation X trusts also a list of third party trust anchors belonging to other federations. I nthis scenario X trusts Y because X trusts Y-TrustAnchor and Y trusts X because X-TrustAnchor. These kind of decision belongs to the trust framework in use and goes beyond the scope of openid federation, therefore I decided to use a SHOULD there",
              "createdAt": "2024-09-21T20:18:36Z",
              "updatedAt": "2024-09-21T20:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86KRtqi",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-21T20:19:31Z",
          "updatedAt": "2024-09-21T20:19:31Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "a response happes after a request, there is space to further describe the flow if you agree in giving more guidance to the reader",
              "createdAt": "2024-09-21T20:19:31Z",
              "updatedAt": "2024-09-21T20:19:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86LgNG_",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T14:04:01Z",
          "updatedAt": "2024-10-01T14:04:01Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "I would not embed challenges values in kid, it's up to the implementers and jwk issuers decide the kid parameter value",
              "createdAt": "2024-10-01T14:04:01Z",
              "updatedAt": "2024-10-01T14:04:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86LgNsv",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T14:04:53Z",
          "updatedAt": "2024-10-01T14:04:53Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "therefore I'd go to server.example.com\r\n\r\nour example would give more guidance to facilitate the readers in having a good read experience",
              "createdAt": "2024-10-01T14:04:53Z",
              "updatedAt": "2024-10-01T14:04:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86LuYLU",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-02T22:18:17Z",
          "updatedAt": "2024-10-02T22:18:17Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "From off-PR discussion: I think we should define, probably in another PR, what fields are filled out in the X.509 certificates. RFC 8555 ACME is concerned with validating a domain, and will generate a certificate for that domain. But in a multitenant situation, both tenants of a given domain would get a certificate associating the relevant key to the domain, which I think is not desirable.\r\n\r\nI'm unaware of what will be consuming these certificates, and especially in what they will expect. Is this something we are free to define, or are there designs/implementations that are already consuming the X.509 certificates this design would be creating?\r\n\r\nWe should also specify the public key that is included in the certificate -- IIRC from our discussion, this is the same public key that is included in the Entity Configuration.",
              "createdAt": "2024-10-02T22:18:17Z",
              "updatedAt": "2024-10-02T22:18:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86LuaVG",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-02T22:27:55Z",
          "updatedAt": "2024-10-02T22:27:55Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "I added a non-normative example of what the challenge object would like like post-validation.",
              "createdAt": "2024-10-02T22:27:55Z",
              "updatedAt": "2024-10-02T22:27:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Luaxf",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-02T22:29:58Z",
          "updatedAt": "2024-10-02T22:29:58Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Hmm -- there are two types of keys in play here:\r\n\r\n1. ACME account keys. This is identified by the `kid` field referenced in this comment. I think this should stay the same.\r\n\r\n2. OpenID entity keys. We should decide where to place this `kid` field. I think we could either have the server check all keys published in the entity configuration, or have the client include a `kid` field in the key response identifying which OpenID entity key is used to meet the challenge.",
              "createdAt": "2024-10-02T22:29:58Z",
              "updatedAt": "2024-10-02T22:29:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ6_NW86Ludl8",
          "commit": {
            "abbreviatedOid": "6d6606f"
          },
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-02T22:43:33Z",
          "updatedAt": "2024-10-02T22:43:33Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "I updated all of the domain names to be `issuer.example.com` (matching some pre-existing URIs for the issuer) or `requestor.example.com`.",
              "createdAt": "2024-10-02T22:43:33Z",
              "updatedAt": "2024-10-02T22:45:21Z"
            }
          ]
        }
      ]
    }
  ]
}